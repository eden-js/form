<eden-fields>
  <div>
    <div class="eden-fields eden-blocks" if={ !state.reorder }>

      <div class={ `${ classes({ 'empty' : !getFields().length, 'eden-dropzone' : !props.preview }) }` } data-form={ props.placement } data-placement="">
        <span class="eden-dropzone-label" if={ !props.preview }>
          { form.get('title') || form.get('placement') }
        </span>

        <eden-add type="top" onclick={ (e) => onCreate(e) } if={ !props.preview } />

        <div class="row form-fields">
          <div each={ (field, i) in getFields() } is={ getType(field) } class={ `${field.col ? 'col' : 'col-12'} ${field.class}` } preview={ preview } form={ form } id={ field.uuid } dataValue={ getValue(field) } field={ field } get-id={ getId } get-name={ getName } on-save={ onSaveField } on-remove={ onRemoveField } on-update={ onUpdate } />
        </div>

        <eden-add type="bottom" onclick={ (e) => onCreate(e) } if={ !props.preview } />

      </div>
    </div>

    <div if={ state.reorder } class="text-center">
      <i class="h1 my-5 fa fa-spinner fa-spin" />
    </div>

    <field-sidebar ref={ ref('sidebar') } loading={ loading } placement={ props.placement } fields={ props.fields } />
  </div>

  <script>
    // import base
    import uuid from 'uuid';
    import slug from 'slug';
    import Base from '../js/base';
    import Model from '../js/model';
    import dotProp from 'dot-prop';

    // export default
    export default class EdenFields extends Base {


      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on before mount
       *
       * @param {Object} props
       */
      onBeforeMount(...args) {
        // super on before mount
        super.onBeforeMount(...args);

        // do mixin
        Model(this);

        // set form
        if (this.props.model) {
          // is model
          this.form = this.props.model;
        } else if (typeof this.props.form === 'string') {
          // is string
          this.form = this.model('form', {
            id : this.props.form,
          });
        } else {
          // nothing
          this.form = this.model('form', this.props.form || {})
        }

        // set update
        this.preview   = !!this.props.preview;
        this.placement = null;

        // get fields
        this.build = this.build.bind(this);
        this.getId = this.getId.bind(this);
        this.getName = this.getName.bind(this);
        this.getValue = this.getValue.bind(this);
        this.setFields = this.setFields.bind(this);
        this.getFields = this.getFields.bind(this);
        this.onSaveField = this.onSaveField.bind(this);
        this.onMouseMoved = this.onMouseMoved.bind(this);
        this.onRemoveField = this.onRemoveField.bind(this);
      }

      /**
       * on updated
       *
       * @param {Object} props
       */
      onUpdated(...args) {
        // super on before mount
        super.onUpdated(...args);

        // check frontend
        if (!this.eden.frontend) return;

        // on mounted
        this.build();
      }

      /**
       * on mounted
       *
       * @param {Object} props
       */
      onMounted(...args) {
        // super on before mount
        super.onMounted(...args);

        // check frontend
        if (!this.eden.frontend) return;

        // build
        this.build();
      }

      /**
       * on before unmount
       */
      onBeforeUnmount(...args) {
        // on before unmount
        super.onBeforeUnmount(...args);

        // set fields
        this.form.removeListener('fields', this.setFields);

        // sortables
        if (this.sortables) {
          // destroy
          this.sortables.forEach((sortable) => sortable.destroy());
        }

        // popover
        $('body > .tooltip').remove();
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // INIT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * build
       */
      async build () {
        // init tooltips
        $('[data-toggle="tooltip"]').tooltip();
        
        // destroy sortables
        (this.sortables || []).forEach((sortable) => sortable.destroy());
        this.sortables = [];
        
        // check preview
        if (!this.props.preview) {
          // init sort
          this.initSort();
        }

        // set updating
        if (!this.hasChange() || this.loading('setup')) return;

        // force update
        this.loading('setup', true);
        
        // check placement
        if (this.placement !== this.props.placement || this.form.get('placement') !== this.props.placement) {
          // check form
          if (this.form) {
            // remove listeners
            this.form.removeListener('fields', this.setFields);
          }

          // set placement
          this.placement = this.props.placement;

          // set form
          if (this.props.model) {
            // is model
            this.form = this.props.model;
          } else if (typeof this.props.form === 'string') {
            // is string
            this.form = this.model('form', {
              id : this.props.form,
            });
          } else {
            // nothing
            this.form = this.model('form', this.props.form || {})
          }

          // load fields
          if (!(this.form.get('fields') || []).length) await this.init();

          // set fields
          this.form.on('fields', this.setFields);

          // set default positions
          if (this.props.positions && !(this.form.get('fields') || []).length) {
            // set default
            this.form.set('fields', this.props.positions || []);

            // save fields
            this.saveForm();
          }
        }

        // set position
        this.preview = !!this.props.preview;

        // force update
        this.loading('setup', false);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // EVENT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////


      // ////////////////////////////////////////////////////////////////////////////
      //
      // GET METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * returns field name
       */
      getName(name) {
        // check name
        if (this.props.getName) {
          return this.props.getName(name);
        }

        // return name
        return name;
      }

      /**
       * returns field name
       */
      getId(id) {
        // check name
        if (this.props.getName) {
          id = this.props.getName(id);
        }

        // return name
        return slug(id, { lower : true });
      }

      /**
       * get field data
       *
       * @param  {Object} field
       *
       * @return {*}
       */
      getValue (field) {
        // return on no field
        if (!field) return;

        // get found
        const found = this.form.get(`data.${field.name}`) || this.form.get(`data.${field.uuid}`);

        // gets data for field
        if (!found) return null;

        // return found
        return found;
      }

      /**
       * get element
       *
       * @param  {Object} child
       *
       * @return {*}
       */
      getType (child) {
        // return get child
        return `field-${child.type}`;
      }

      /**
       * get fields
       *
       * @return {Array}
       */
      getFields () {
        // return filtered fields
        return (this.form.get('fields') || []).filter((f) => f).sort((a, b) => {
          // set order
          if (!a.order) a.order = 0;
          if (!b.order) b.order = 0;

          // get order
          if (a.order > b.order) return 1;
          if (a.order < b.order) return -1;

          // return no change
          return 0;
        });
      }

      /**
       * on refresh field
       *
       * @param  {Event}  e
       * @param  {Object} field
       */
      async onSaveField (field, preventUpdate) {
        // update view
        if (!preventUpdate) this.loading(`field.${field.uuid}`, true);

        // set data
        const actualField = (this.form.get('fields') || []).find((f) => f.uuid === field.uuid);

        // set data
        for (const key in field) {
          // set value
          actualField[key] = field[key];
        }

        // build meta
        if (!field._meta) {
          // set created
          field._meta = {
            created : new Date(),
          };
        }

        // set updated
        field._meta.updated = new Date();

        // log data
        const res = await fetch(`/form/${this.form.get('id')}/field/save`, {
          body : JSON.stringify({
            field : field
          }),
          method  : 'post',
          headers : {
            'Content-Type' : 'application/json'
          },
          credentials : 'same-origin'
        });

        // load data
        const result = await res.json();

        // fields
        const fields = this.form.get('fields') || [];

        // check found
        if (!fields.find((f) => f.uuid === field.uuid)) {
          // add
          fields.push(field);
          this.form.set('fields', fields);
        }

        // set logic
        for (let key in result.result) {
          // clone to form
          field[key] = result.result[key];
        }

        // update view
        if (!preventUpdate) {
          // loading
          this.loading(`field.${field.uuid}`, false);
        } else {
          // update
          this.update();
        }
      }

      /**
       * on refresh field
       *
       * @param  {Event}  e
       * @param  {Object} field
       */
      async onRemoveField (field, data) {
        // update view
        this.loading(`field.${field.uuid}`, true);

        // log data
        const res = await fetch(`/form/${this.form.get('id')}/field/remove`, {
          body : JSON.stringify({
            data  : data,
            field : field
          }),
          method  : 'post',
          headers : {
            'Content-Type' : 'application/json'
          },
          credentials : 'same-origin'
        });

        // load data
        const result = await res.json();

        // set fields
        this.form.set('fields', (this.form.get('fields') || []).filter(f => f.uuid !== field.uuid));

        // update view
        this.loading(`field.${field.uuid}`, false);
      }

      /**
       * on mouse moved
       *
       * @param {Event} e
       */
      onMouseMoved (e) {
        // check dragging
        if (!this.dragging) return;

        // width
        const maxTop = jQuery(window).height() / 2;
        const maxLeft = jQuery(window).width() - jQuery('.eden-blocks-sidebar').width();

        // out
        const out = { x : 0, y : 0 };

        // type
        if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
          const touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
          out.x = touch.pageX;
          out.y = touch.pageY;
        } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
          out.x = e.pageX;
          out.y = e.pageY;
        }

        // showing
        if (out.x > maxLeft && !this.refs.sidebar.state.showing && this.dragging) {
          // show
          this.refs.sidebar.show();
        } else if (out.x < maxLeft && this.refs.sidebar.state.showing && this.dragging) {
          // hide
          this.refs.sidebar.hide();
        }
      }

      /**
       * on add block
       *
       * @param {Event} e
       */
      onCreate (e) {
        // prevent
        e.preventDefault();
        e.stopPropagation();

        // show sidebar
        this.refs.sidebar.show();
      }

      /**
       * saves form
       *
       * @return {Promise}
       */
      async saveForm (preventRefresh) {
        // set loading
        this.loading('save', true);

        // check type
        if (!this.form.type) this.form.set('type', this.props.type);

        // log data
        let res = await fetch(`/form/${this.form.get('id') ? this.form.get('id') + '/update' : 'create'}`, {
          'body'    : JSON.stringify(this.form.get()),
          'method'  : 'post',
          'headers' : {
            'Content-Type' : 'application/json'
          },
          'credentials' : 'same-origin'
        });

        // load data
        let data = await res.json();

        // set logic
        for (let key in data.result) {
          // clone to form
          this.form.set(key, data.result[key]);

          // set in opts
          if (this.props.form && data.result[key] && !this.props.model) this.props.form[key] = data.result[key];
        }

        // on save
        if (this.props.onSave) this.props.onSave(this.form);

        // set loading
        this.loading('save', false);
      }

      /**
       * set fields
       */
      setFields() {
        
      }

      /**
      * loads form fields
      *
      * @param  {Object} opts
      *
      * @return {Promise}
      */
      init (opts) {
        // chekc loading
        if (this.initializing) return this.initializing;

        // loading fields
        this.initializing = new Promise(async (resolve) => {
          // set opts
          if (!opts) opts = {};

          // require query string
          const qs = require('querystring');

          // set opts
          opts = qs.stringify(opts);

          // log data
          const res = await fetch(`/form/${this.form.get('id') ? `${this.form.get('id')}/view` : 'create'}${(opts.length ? '?' + opts : '')}`, {
            body : JSON.stringify({
              placement : this.props.placement || this.form.get('placement') || (this.props.form || {}).placement,
            }),
            method  : 'post',
            headers : {
              'Content-Type' : 'application/json'
            },
            credentials : 'same-origin'
          });

          // load data
          const data = await res.json();

          // set in eden
          if (data.result) {
            // change form
            if (!this.form.get('id') && data.result.id) {
              // set new form
              this.form = this.model('form', data.result);
            } else {
              // set fields
              for (let key in data.result) {
                // set key
                this.form.set(key, data.result[key]);
              }
            }
          }

          // resolve
          resolve();

          // remove promise
          this.initializing = null;
        });

        // loading fields
        return this.initializing;
      }

      /**
      * init dragula
      */
      initSort () {
        // require sort
        const Sortable = require('sortablejs');

        // create sortables
        [this.$(`[data-form="${this.props.placement}"] .form-fields`), this.$(`.eden-blocks-sidebar[data-form="${this.props.placement}"] .draggable`)].forEach((item) => {
          // sometimes can be missing
          if (!item) return;

          // push
          this.sortables.push(new Sortable(item, {
            group : {
              pull : item.getAttribute('data-type') ? 'clone' : true,
              name : this.props.placement,
            },
            handle         : '.move, [data-type]',
            animation      : 200,
            forceFallback  : true,
            fallbackOnBody : true,

            onStart : (e) => {
              // add class
              this.dragging = true;

              // add listener
              $(document).on('mousemove', this.onMouseMoved);
            },

            onEnd : async (e) => {
              // add class
              this.dragging = false;

              // add listener
              $(document).off('mousemove', this.onMouseMoved);

              // set item
              const el     = e.item;
              const target = e.to;
              const source = e.from;

              // check target
              if (!target) return;

              // check position
              if (el.getAttribute('id') && $(target).closest('.eden-blocks-sidebar').length) {
                // get field
                const field = (this.form.get('fields') || []).find((fi) => fi.uuid === el.getAttribute('id'));

                // check
                if (field.uuid) {
                  // on remove
                  await this.onRemoveField(field, {});

                  // update
                  this.safeUpdate({
                    reorder : true,
                  });

                  // update
                  return setTimeout(() => this.safeUpdate({
                    reorder : false,
                  }), 10);
                }
              }

              // check target
              if (!target || !source || !el || (target && !target.className.includes('form-fields'))) return;

              // set fields
              const fields = [];
              let addedField = null;

              // loop physical fields
              target.childNodes.forEach((f, i) => {
                // check placement
                if (!f.getAttribute) return;
                
                // set get from
                let fieldItem = (this.form.get('fields') || []).find((fi) => fi.uuid === f.getAttribute('id'));

                // return on no field
                if (!fieldItem) {
                  // create new field
                  addedField = {
                    type : el.getAttribute('data-type'),
                    uuid : uuid(),
                  };
                  fieldItem = addedField;
                }

                // set order
                fieldItem.order = i;

                // get actual field
                fields.push(fieldItem);
              });

              // update form
              this.form.set('fields', fields);

              // save form
              if (addedField) {
                // added field
                await this.onSaveField(addedField);
              }

              // update
              this.safeUpdate({
                reorder : true,
              });

              // update
              setTimeout(() => this.safeUpdate({
                reorder : false,
              }), 10);

              // save
              this.saveForm();
            }
          }));
        });
      }

      /**
      * returns true if form changed
      *
      * @return {Boolean}
      */
      hasChange() {
        // check matched preview
        if (!!this.props.preview !== !!this.preview) {
          // preview does not match
          return true;
        }

        // check matched preview
        if (this.props.placement !== this.placement) {
          // preview does not match
          return true;
        }

        // return false
        return false;
      }
    }
  </script>
</eden-fields>
