<eden-fields>
  <div class="eden-fields eden-blocks">

    <div class={ `${ classes({ 'empty' : !getFields().length, 'eden-dropzone' : !props.preview }) }` } data-placement="" if={ !updating }>
      <span class="eden-dropzone-label" if={ !props.preview }>
        { form.get('title') || form.get('placement') }
      </span>

      <eden-add type="top" onclick={ (e) => onAddBlock(e) } if={ !preview } />
      <div each={ (el, i) in getFields() } data-is={ getElement(el) } is={ getElement(el) } el={ el } class={ el.class } preview={ preview } data-field={ el.uuid } data={ getField(el) } field={ el } get-field={ getField } on-save={ onSaveField } on-remove={ onRemoveField } on-refresh={ onRefreshField } on-update={ onUpdate } placement={ i } i={ i } />
      <eden-add type="bottom" onclick={ (e) => onAddBlock(e) } if={ !preview } />

    </div>
  </div>

  <field-sidebar ref={ ref('sidebar') } fields={ props.fields } />

  <script>
    // import base
    import uuid from 'uuid';
    import Base from '../js/base';
    import Model from '../js/model';

    // export default
    export default class EdenFields extends Base {

      /**
       * on before mount
       *
       * @param {Object} props
       */
      onBeforeMount(props) {
        // super on before mount
        super.onBeforeMount(...arguments);

        // do mixin
        Model(this);

        // set update
        this.form     = props.form ? (props.model ? props.model : this.model('form', props.form)) : this.model('form', {});
        this.type     = props.type;
        this.fields   = (props.form || {}).render || [];
        this.preview  = !!props.preview;
        this.updating = false;

        // set filter fields
        this.filter = {
          fix     : this.filterFix.bind(this),
          place   : this.filterPlace.bind(this),
          flatten : this.filterFlatten.bind(this),
          replace : this.filterReplace.bind(this),
        };

        // get fields
        this.getField = this.getField.bind(this);
        this.getFields = this.getFields.bind(this);
        this.onSaveField = this.onSaveField.bind(this);
        this.onMouseMoved = this.onMouseMoved.bind(this);
        this.onRemoveField = this.onRemoveField.bind(this);
      }

      /**
       * on updated
       *
       * @param {Object} props
       */
      onUpdated(props) {
        // super on before mount
        super.onUpdated(...arguments);

        // check frontend
        if (!this.eden.frontend) return;
        
        // check has change
        if (this.hasChange() && !this.updating) {
          // check placement
          if (this.placement !== this.props.placement) {
            // updating
            this.updating = true;
            this.update();
          }

          // on mounted
          this.onMounted(...arguments);
        }

        // set containers
        if (this.dragula) this.dragula.containers = [...(this.$$('.eden-dropzone')), ...(this.$$('.eden-blocks-sidebar .list-group'))];
      }

      /**
       * on mounted
       *
       * @param {Object} props
       */
      onMounted() {
        // super on before mount
        super.onMounted(...arguments);

        // check frontend
        if (!this.eden.frontend) return;

        // props
        const props = this.props;

        // set form
        this.form = props.form ? (props.model ? props.model : this.model('form', props.form)) : this.model('form', {});

        // init dragula
        if (!this.dragula && !props.preview) this.initDragula();

        // set default positions
        if (props.positions && !(this.form.get('positions') || []).length && !this.form.get('id')) {
          // set default
          this.form.set('positions', props.positions);
          this.form.set('fields', (this.form.get('positions') || []).reduce(this.filter.flatten, []));

          // save fields
          this.saveForm();
        }

        // set positions
        if (this.hasChange()) {
          // set position
          this.type    = props.type;
          this.preview = !!props.preview;

          // placement
          this.updating  = false;
          this.placement = props.placement;

          // force update
          this.update();
        }

        // check fields
        if (this.shouldLoad()) {
          // load fields
          this.loadFields();
        }
      }

      /**
       * on before unmount
       */
      onBeforeUnmount() {
        // on before unmount
        super.onBeforeUnmount(...arguments);

        // off mousemove        
        jQuery('body').off('mousemove', this.onMouseMoved);
      }

      /**
       * get field data
       *
       * @param  {Object} field
       *
       * @return {*}
       */
      getField (field) {
        // return on no field
        if (!field) return;

        // get found
        let found = this.fields.find((b) => b.uuid === field.uuid || (field.name && b.name && field.name === b.name));

        // gets data for field
        if (!found) return null;

        // return found
        return found;
      }

      /**
       * get element
       *
       * @param  {Object} child
       *
       * @return {*}
       */
      getElement (child) {
        // return get child
        return (this.getField(child) || {}).tag ? `field-${this.getField(child).tag}` : 'eden-loading';
      }

      /**
       * get fields
       *
       * @return {Array}
       */
      getFields () {
        // return filtered fields
        return (this.form.get('positions') || []).map(this.filter.fix).filter((field) => field);
      }

      /**
       * on refresh field
       *
       * @param  {Event}  e
       * @param  {Object} field
       */
      async onSaveField (field, data = {}, form, preventUpdate) {
        // clone
        let fieldClone = Object.assign({}, field);

        // prevent update check
        if (!preventUpdate) {
          // set loading
          field.saving = true;

          // update view
          this.update();
        }

        // log data
        let res = await fetch('/form/' + this.form.get('id') + '/field/save', {
          'body' : JSON.stringify({
            'data'  : data,
            'field' : fieldClone
          }),
          'method'  : 'post',
          'headers' : {
            'Content-Type' : 'application/json'
          },
          'credentials' : 'same-origin'
        });

        // load data
        let result = await res.json();

        // set logic
        for (let key in result.result) {
          // clone to form
          data[key] = result.result[key];
        }

        // set to fields
        if (!this.fields.find((b) => b.uuid === data.uuid)) this.fields.push(data);
        
        // set flat
        this.form.set('positions', (this.form.get('positions') || []).map(this.filter.replace(fieldClone)));
        this.form.set('fields', (this.form.get('positions') || []).reduce(this.filter.flatten, []));

        // save form
        await this.saveForm(preventUpdate);

        // check prevent update
        if (!preventUpdate) {
          // set loading
          delete field.saving;

          // update view
          this.update();
        }
      }

      /**
       * on refresh field
       *
       * @param  {Event}  e
       * @param  {Object} field
       */
      async onRefreshField (field, data) {
        // set loading
        field.refreshing = true;

        // update view
        this.update();

        // log data
        let res = await fetch('/form/' + this.form.get('id') + '/field/save', {
          'body' : JSON.stringify({
            'data'  : data,
            'field' : field
          }),
          'method'  : 'post',
          'headers' : {
            'Content-Type' : 'application/json'
          },
          'credentials' : 'same-origin'
        });

        // load data
        let result = await res.json();

        // set logic
        for (let key in result.result) {
          // clone to form
          data[key] = result.result[key];
        }

        // set loading
        delete field.refreshing;

        // update view
        this.update();
      }

      /**
       * on refresh field
       *
       * @param  {Event}  e
       * @param  {Object} field
       */
      async onRemoveField (field, data, form) {
        // get uuid
        const dotProp = require('dot-prop-immutable');

        // set loading
        this.updating = true;
        field.removing = true;

        // update view
        this.update();

        // log data
        let res = await fetch('/form/' + this.form.get('id') + '/field/remove', {
          'body' : JSON.stringify({
            'data'  : data,
            'field' : field
          }),
          'method'  : 'post',
          'headers' : {
            'Content-Type' : 'application/json'
          },
          'credentials' : 'same-origin'
        });

        // load data
        let result = await res.json();

        // get positions
        let positions = (this.form.get('positions') || []).map(this.filter.fix).filter((field) => field);

        // set moving on field
        positions = dotProp.set(positions, `${form}.removing`, true);

        // get positions
        this.form.set('positions', positions.map(this.filter.place).filter((field) => field));
        this.form.set('fields', (this.form.get('positions') || []).reduce(this.filter.flatten, []));

        // set loading
        this.updating = false;

        // update view
        this.update();

        // save form
        await this.saveForm();
      }

      /**
       * on mouse moved
       *
       * @param {Event} e
       */
      onMouseMoved (e) {
        // width
        const maxTop = jQuery(window).height() / 2;
        const maxLeft = jQuery(window).width() - jQuery('.eden-blocks-sidebar').width();

        // out
        const out = { x : 0, y : 0 };

        // type
        if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
          const touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
          out.x = touch.pageX;
          out.y = touch.pageY;
        } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
          out.x = e.pageX;
          out.y = e.pageY;
        }

        // showing
        if (out.x > maxLeft && !this.refs.sidebar.state.showing && this.dragging) {
          // show
          this.refs.sidebar.show();
        } else if (out.x < maxLeft && this.refs.sidebar.state.showing && this.dragging) {
          // hide
          this.refs.sidebar.hide();
        }
      }

      /**
       * on add block
       *
       * @param {Event} e
       */
      onAddBlock (e) {
        // prevent
        e.preventDefault();
        e.stopPropagation();

        // show sidebar
        this.refs.sidebar.show();
      }

      /**
       * adds field by type
       *
       * @param  {String} type
       *
       * @return {*}
       */
      async onUpdate () {
        // update view
        this.update();
      }

      /**
       * saves form
       *
       * @return {Promise}
       */
      async saveForm (preventRefresh) {
        // set loading
        this.loading('save', true);

        // check type
        if (!this.form.type) this.form.set('type', this.props.type);

        // log data
        let res = await fetch('/form/' + (this.form.get('id') ? this.form.get('id') + '/update' : 'create'), {
          'body'    : JSON.stringify(this.form.get()),
          'method'  : 'post',
          'headers' : {
            'Content-Type' : 'application/json'
          },
          'credentials' : 'same-origin'
        });

        // load data
        let data = await res.json();

        // set logic
        for (let key in data.result) {
          // clone to form
          this.form.set(key, data.result[key]);

          // set in opts
          if (this.props.form && data.result[key] && !this.props.model) this.props.form[key] = data.result[key];
        }
        
        // set fields
        const missing = (this.form.get('render') || []).filter((field) => !this.fields.find((f) => f.uuid === field.uuid));
        
        // push missing fields
        this.fields.push(...missing);
        
        // set forms
        if (!window.eden.forms) window.eden.forms = {};

        // set in eden
        window.eden.forms[this.form.get('id')] = data.result;

        // on save
        if (this.props.onSave) this.props.onSave(this.form);

        // set loading
        this.loading('save', false);
      }

      /**
      * loads form fields
      *
      * @param  {Object} opts
      *
      * @return {Promise}
      */
      async loadFields (opts) {
        // set opts
        if (!opts) opts = {};

        // return on loading fields
        if (this.loading('fields')) return;

        // require query string
        const qs = require('querystring');

        // set opts
        opts = qs.stringify(opts);

        // set loading
        this.loading('fields', true);

        // log data
        let res = await fetch((this.form.get('id') ? '/form/' + this.form.get('id') + '/view' : '/form/create') + (opts.length ? '?' + opts : ''), {
          'method'  : 'get',
          'headers' : {
            'Content-Type' : 'application/json'
          },
          'credentials' : 'same-origin'
        });

        // load data
        let data = await res.json();

        // set in eden
        if (data.result) {
          // set forms
          if (!window.eden.forms) window.eden.forms = {};
            
          // set in eden
          window.eden.forms[this.form.get('id')] = data.result;

          // set fields
          for (let key in data.result) {
            // set key
            this.form.set(key, data.result[key]);
          }
          
          // set fields
          const missing = (this.form.get('render') || []).filter((field) => !this.fields.find((f) => f.uuid === field.uuid));
          
          // push missing fields
          this.fields.push(...missing);

          // set loading
          this.loading('fields', false);
        }
      }

      /**
      * init dragula
      */
      initDragula () {
        // require dragula
        const dragula = require('dragula');
        const dotProp = require('dot-prop-immutable');

        // do dragula
        this.dragula = dragula([...(this.$$('.eden-dropzone')), ...(this.$$('.eden-blocks-sidebar .list-group'))], {
          moves : (el, container, handle) => {
            return container.className.includes('list-group') || ((jQuery(el).is('[data-field]') || jQuery(el).closest('[data-field]').length) && (jQuery(handle).is('.move') || jQuery(handle).closest('.move').length) && (jQuery(handle).is('.move') ? jQuery(handle) : jQuery(handle).closest('.move')).attr('for') === jQuery(el).attr('data-field'));
          },
          copy : (el, container) => {
            // check container class
            return jQuery(container).closest('.eden-blocks-sidebar').length;
          }
        }).on('drop', async (el, target, source, sibling) => {
          // get parent
          target = el.parentNode;

          // get current form
          let addedField = {};
          const placement = el.getAttribute('placement') || null;
          const position = target.getAttribute('data-placement');

          // get positions
          let positions = (this.form.get('positions') || []).map(this.filter.fix).filter((field) => field);

          // check position
          if (jQuery(target).closest('.eden-blocks-sidebar').length) {
            // check
            if (placement && !position) {
              // set get from
              let getFrom = el.getAttribute('placement') || null;
              let gotField = getFrom ? dotProp.get(positions, getFrom) : null;
              
              // check got field
              if (gotField) {
                // remove el
                jQuery(el).remove();

                // on remove
                return this.onRemoveField(gotField, {}, getFrom);
              }
            }
          }

          // check target
          if (!target || !source || !el || (target && !target.className.includes('eden-dropzone'))) return;

          // get fields of target
          let fields = [];

          // set moving on field
          if (placement) positions = dotProp.set(positions, placement + '.moving', true);

          // loop physical fields
          target.childNodes.forEach((field) => {
            // check placement
            if (!field.getAttribute) return;
            if (!field.getAttribute('data-type') && !field.getAttribute('placement')) return;
            
            // set get from
            let getFrom = field.getAttribute('placement') || null;
            let gotField = getFrom ? dotProp.get(positions, getFrom) : null;

            // return on no field
            if (!gotField && placement) return;

            // clone field
            if (getFrom === placement || field.getAttribute('data-type') === el.getAttribute('data-type')) {
              // clone field
              gotField = gotField ? JSON.parse(JSON.stringify(gotField)) : {
                type : el.getAttribute('data-type'),
                uuid : uuid(),
              };

              // delete placing
              if (gotField.moving) delete gotField.moving;

              // set field
              addedField = gotField;
            }

            // get actual field
            fields.push(gotField);
          });

          // remove logic
          this.updating = true;
          this.update();

          // set form
          if ((position || '').length) {
            // get
            if (!dotProp.get(positions, position)) {
              positions = dotProp.set(positions, position, []);
            }

            // set positions
            positions = dotProp.set(positions, position, fields);
          } else {
            // set positions
            positions = fields;
          }

          // get positions
          positions = (positions || []).map(this.filter.place).filter((field) => field);

          // update form
          this.form.set('positions', positions);

          // remove logic
          this.updating = false;
          this.update();

          // save form
          if (!placement) await this.onSaveField(addedField, {});

          // save
          this.saveForm();
        }).on('drag', (el, source) => {
          // add is dragging
          this.dragging = true;
        }).on('dragend', () => {
          // remove is dragging
          this.dragging = false;
        }).on('over', function (el, container) {
          // add class
          
        }).on('out', function (el, container) {
          // remove class
          
        });
        
        // add listener
        jQuery('body').on('mousemove touchmove', this.onMouseMoved);
      }

      /**
      * returns true if form changed
      *
      * @return {Boolean}
      */
      hasChange() {
        // check matched type
        if (this.props.type !== this.type) {
          // type does not match
          return true;
        }

        // check matched preview
        if (!!this.props.preview !== !!this.preview) {
          // preview does not match
          return true;
        }

        // check matched preview
        if (this.props.placement !== this.placement) {
          // preview does not match
          return true;
        }

        // check matched model
        if ((!this.props.model && (this.props.form || {}).id !== this.form.get('id'))) {
          // form id does not match
          return true;
        }

        // return false
        return false;
      }

      /**
      * returns true if should load
      *
      * @return {Boolean}
      */
      shouldLoad() {
        // check matched fields length
        if ((this.form.get('fields') || []).length !== this.fields.length) {
          // field lengths do not match
          return true;
        }

        // check if empty form
        if (!(this.form.get('fields') || []).length && !(this.eden.get('forms') || {})[this.form.get('id')]) {
          // field lengths do not match
          return true;
        }

        // return false
        return false;
      }

      // ////////////////////////////////////////////////////////////////////////////
      //
      // Filter Methods
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
      * filter fix
      *
      * @param  {Object} field
      *
      * @return {Object}
      */
      filterFix(field) {
        // standard children fields
        const children = ['left', 'right', 'children'];

        // return if moving
        if (!field) return null;

        // check children
        for (const child of children) {
          // check child
          if (field[child]) {
            // remove empty fields
            field[child] = Object.values(field[child]).filter(f => f);

            // push children to flat
            field[child] = field[child].map(this.filter.fix);
          }
        }

        // return accum
        return field;
      }

      /**
      * filter field
      *
      * @param  {Object} field
      *
      * @returns {Object}
      */
      filterPlace(field) {
        // standard children fields
        const children = ['left', 'right', 'children'];

        // return if moving
        if (field.moving || field.removing) return null;

        // check children
        for (const child of children) {
          // check child
          if (field[child]) {
            // remove empty fields
            field[child] = Object.values(field[child]);

            // push children to flat
            field[child] = field[child].map(this.filter.place).filter(f => f);
          }
        }

        // return accum
        return field;
      }

      /**
      * filter flatten
      *
      * @param  {Array}  accum
      * @param  {Object} field
      *
      * @returns {Array}
      */
      filterFlatten(accum, field) {
        // standard children fields
        const children = ['left', 'right', 'children'];

        // get sanitised
        const sanitised = JSON.parse(JSON.stringify(field));

        // loop for of
        for (const child of children) {
          // delete child field
          delete sanitised[child];
          delete sanitised.saving;
        }

        // check field has children
        accum.push(sanitised);

        // check children
        for (const child of children) {
          // check child
          if (field[child]) {
            // remove empty fields
            field[child] = field[child].filter(f => f);

            // push children to flat
            accum.push(...field[child].reduce(this.filter.flatten, []));
          }
        }

        // return accum
        return accum;
      }

      /**
      * filter replace
      *
      * @param  {Field} b
      *
      * @returns {*}
      */
      filterReplace(b) {
        // return field
        return (field) => {
          // standard children fields
          const children = ['left', 'right', 'children'];

          // return if moving
          if (field.moving || field.removing) return null;

          // set field info for replace
          if (field.uuid === b.uuid) {
            // remove
            Object.keys(b).forEach((key) => {
              // set key
              field[key] = b[key];
            });
          }

          // check children
          for (const child of children) {
            // check child
            if (field[child]) {
              // remove empty fields
              field[child] = Object.values(field[child]);

              // push children to flat
              field[child] = field[child].map(this.filter.replace(b)).filter(f => f);
            }
          }

          // return accum
          return field;
        };
      }
    }
  </script>
</eden-fields>
